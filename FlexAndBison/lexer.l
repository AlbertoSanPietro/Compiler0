/* lexer.l â€“ Flex lexer */

%{
#include "parser.tab.h"     /* token definitions generated by Bison */
#include <stdlib.h>
%}

%%

/* Keywords */
"int"       { return INT; }
"return"    { return RETURN; }
"if"        { return IF; }
"else"      { return ELSE; }
"while"     { return WHILE; }

/* Relational and equality operators */
"=="        { return EQ; }
"!="        { return NE; }
"<="        { return LE; }
">="        { return GE; }
"<"         { return '<'; }
">"         { return '>'; }

/* Arithmetic operators and punctuation */
"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
"%"         { return '%'; }
"="         { return '='; }
";"         { return ';'; }
"("         { return '('; }
")"         { return ')'; }
"{"         { return '{'; }
"}"         { return '}'; }

/* Identifiers and numbers */
[ \t\r\n]+  { /* skip whitespace */ }
[0-9]+      {
                yylval.ival = atoi(yytext);
                return NUMBER;
            }
[A-Za-z_][A-Za-z0-9_]* {
                yylval.sval = strdup(yytext);
                return IDENTIFIER;
            }

/* Comments (C-style and C++-style) */
"//".*      { /* skip to end of line */ }
"/*"([^*]|\*+[^*/])*\*+ "/"   { /* skip block comment */ }

.           { /* any other char is error */ 
                fprintf(stderr, "Unexpected character '%s'\n", yytext);
                exit(1);
            }

%%

int yywrap(void) { return 1; }

